#!/usr/bin/env python

# Copyright (C) 2017 Pier Carlo Chiodi
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import json
import logging
import math
import os
from six.moves import queue
from six.moves.urllib.request import urlopen
from six.moves.urllib.error import HTTPError
import sys
import threading

try:
    import napalm_base
except ImportError:
    print("")
    print("ERROR: can't load NAPALM library.")
    print("")
    print("Please install it by executing a full installation... ")
    print("")
    print("   pip install napalm")
    print("")
    print("... or a partial installation based on the subset of "
          "drivers you really need:")
    print("")
    print("   pip install napalm-ios napalm-junos")
    print("")
    print("Details here: https://napalm.readthedocs.io/en/latest/installation/index.html")
    print("")
    sys.exit(1)

from pierky.mactopeer import MACToPeer_JSON, MACToPeer_pmacct
from pierky.mactopeer.cli import build_devices, build_filters
from pierky.mactopeer.errors import MACToPeerError
from pierky.mactopeer.version import __version__, COPYRIGHT_YEAR

logger = logging.getLogger("mac-to-peer")
logger.setLevel(logging.INFO)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

def get_optional_args(s):
    return {x.split('=')[0]: x.split('=')[1]
            for x in s.split(',')}

def print_help_devices():
    s = """
The JSON file provided via the --devices argument must contain the list of
devices which data will be fetched from.
It must respect the following schema:
[
  {
    "hostname": "IP address or hostname",
    "vendor": "see below",
    "username": "username",
    "password": "password",
    "arp_only": true|false,
    "optional_args": {
      "arg1_name": "arg1_value",
      "arg2_name": "arg2_value",
      ...
    }
    "pmacct_ip": "IP address
  }, {
    <same as above>
  }
]

Only "hostname" and "vendor" are mandatory.

- "hostname" is the IP address or hostname used to connect to the device.

- "vendor" is the name of the driver used by NAPALM to identify the type of 
device: it must be one of the values reported in the "Driver name" row of this
table:
http://napalm.readthedocs.io/en/latest/support/index.html

- "username" and "password" are used to authenticating to the device. The
password can be omitted and provided via CLI by running the program with the
"--password -" argument.

- "arp_only", if set, prevents the program from fetching IPv6 neighbors table
from the devices.

- "optional_args" can be used to pass additional arguments to the NAPALM
driver used to connect to the device. A list of available arguments can be
found here:
http://napalm.readthedocs.io/en/latest/support/index.html#optional-arguments

- "pmacct_ip" is only used when the output format is set to "pmacct"
("--format pmacct" argument); its value is used to fill the "ip" field of
pmacct's "bgp_peer_src_as_map" and it can be used to provide an IP address
different from the one given in "hostname".
"""
    print(s)

def main():
    parser = argparse.ArgumentParser(
        description="mac-to-peer v{}: a tool to automatically "
                    "build a list of BGP neighbors starting from "
                    "the MAC address of their peers.".format(
                        __version__
                    ),
        epilog="Copyright (c) {} - Pier Carlo Chiodi - "
               "https://pierky.com".format(COPYRIGHT_YEAR)
    )
    parser.add_argument(
        "--help-devices",
        help="show details about the format of the JSON file "
             "that must be used to build the --devices file.",
        action="store_true"
    )

    group = parser.add_argument_group(
        title="Device(s) to get the data from",
        description="To use a list of devices the --devices "
                    "argument must be used; a single device can "
                    "be given using the --hostname argument."
    )
    group.add_argument(
        "--devices",
        help="path to the JSON file that contains the list of "
             "devices from which to get the data. Use '-' to "
             "read from stdin. "
             "Use the --help-devices argument to show details "
             "about the format of that JSON file.",
        type=argparse.FileType("r")
    )
    group.add_argument(
        "--hostname",
        help="IP address or hostname of the device from which "
             "to get the data."
    )
    group = parser.add_argument_group(
        title="Device(s) authentication and connection info",
        description="The following arguments, when provided, overried "
                    "those reported within the JSON file given in "
                    "the --devices argument."
    )
    group.add_argument(
        "-u", "--username",
        help="username for authenticating to the device(s)."
    )
    group.add_argument(
        "-p", "--password",
        help="password for authenticating to the device(s). "
             "Use '-' in order to be prompted."
    )
    group.add_argument(
        "-v", "--vendor",
        help="name of the NAPALM driver that must be used to connect to "
             "the device. It is mandatory if --hostname is used. "
             "It must be one of the values from the "
             "'Driver name' row of the following table: "
             "http://napalm.readthedocs.io/en/latest/support/index.html"
             "#general-support-matrix"
    )
    group.add_argument(
        "--arp-only",
        help="when set, it prevents the program from fetching IPv6 neighbors "
             "from the device(s).",
        action="store_true"
    )
    group.add_argument(
        "--optional-args",
        help="list of comma separated key=value pairs passed to "
             "Napalm drivers. For the list of supported optional "
             "arguments see this URL: "
             "http://napalm.readthedocs.io/en/latest/support/index.html#"
             "optional-arguments"
    )

    group = parser.add_argument_group(
        title="Output options"
    )
    group.add_argument(
        "-o", "--output",
        type=argparse.FileType("w"),
        help="output file. Default: stdout.",
        default=sys.stdout,
        dest="output_file"
    )
    group.add_argument(
        "-f", "--format",
        choices=["json", "pmacct"],
        help="output format. When 'pmacct' is used, the output "
             "is built using the format of pmacct's bgp_peer_src_as_map "
             "(https://github.com/pmacct/pmacct/blob/"
             "c9d6b210210bc3232d6c31683103963ab2b15953/QUICKSTART#L1120 "
             "and also "
             "https://github.com/pmacct/pmacct/blob/master/examples/"
             "peers.map.example). Default: %(default)s.",
        default="json"
    )

    group = parser.add_argument_group(
        title="Filters",
        description="The following arguments can be used to filter out "
                    "entries on the basis of their MAC address, IP address "
                    "or peer ASN. Each argument can be set with a "
                    "comma-separated list of values (ex. --ignore-ip "
                    "192.168.0.1,10.0.0.1) or with the path to a file "
                    "containing one value on each line."
    )
    group.add_argument(
        "--ignore-mac",
        help="list of MAC addresses that will be ignored.",
        metavar="LIST_OR_FILE"
    )
    group.add_argument(
        "--ignore-ip",
        help="list of IP addresses or prefixes that will be ignored.",
        metavar="LIST_OR_FILE"
    )
    group.add_argument(
        "--ignore-asn",
        help="list of ASNs that will be ignored.",
        metavar="LIST_OR_FILE"
    )

    group = parser.add_argument_group(
        title="Misc options"
    )
    group.add_argument(
        "--threads",
        type=int,
        help="number of threads that will be used to fetch info "
             "from devices. Default: %(default)s.",
        default=4
    )
    group.add_argument(
        "--use-peeringdb",
        action="store_true",
        help="use PeeringDB to obtain the ASN of those entries which "
             "have not a straight BGP session on the router (for "
             "example multi-lateral peering sessions at IXs via "
             "route server)."
    )
    group.add_argument(
        "--write-to-cache",
        type=argparse.FileType("w"),
        help="if provided, data fetched from devices are saved "
             "into this file for later use via the --read-from-cache "
             "argument.",
        metavar="CACHE_FILE"
    )
    group.add_argument(
        "--read-from-cache",
        type=argparse.FileType("r"),
        help="if provided, data are not fetched from devices but "
             "read from the CACHE_FILE file.",
        metavar="CACHE_FILE"
    )

    args = parser.parse_args()

    if args.help_devices:
        print_help_devices()
        return 0

    if args.format == "json":
        mac_to_peer_class = MACToPeer_JSON
    elif args.format == "pmacct":
        mac_to_peer_class = MACToPeer_pmacct
    else:
        raise NotImplementedError(
            "Unknown format: {}".format(args.format)
        )

    try:
        filters = build_filters(args)
        devices = build_devices(args)
        lib = mac_to_peer_class(
            devices, filters, args.output_file,
            threads=args.threads, use_peeringdb=args.use_peeringdb,
            read_from_file=args.read_from_cache,
            write_to_file=args.write_to_cache
        )
        lib.write_output()
    except MACToPeerError as e:
        print(str(e))
        sys.exit(1)

    return 0

main()
